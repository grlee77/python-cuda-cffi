{
    "handle": "cuSolver context handle",
    "streamId": "CUDA stream ID",
    "m": "number of rows of matrix",
    "n": "number of columns of matrix",
    "nnz": "number of non-zero elements in the matrix",
    "nnzA": "number of non-zero elements in the matrix A",
    "nnzL": "number of non-zero elements in the matrix L",
    "nnzU": "number of non-zero elements in the matrix U",
    "nnzM": "number of non-zero elements in the matrix M",
    "h_nnzM": "number of non-zero elements in the matrix M",
    "h_nnzL": "number of non-zero elements in the matrix L",
    "h_nnzU": "number of non-zero elements in the matrix U",
    "nrhs": "number of columns of rhs matrix",
    "A": "two-dimensional array (matrix) A",
    "B": "two-dimensional array (matrix) B",
    "C": "two-dimensional array (matrix) C",
    "d": "two-dimensional array (matrix) d",
    "D": "two-dimensional array (matrix) D",
    "e": "two-dimensional array (matrix) e",
    "E": "two-dimensional array (matrix) E",
    "S": "two-dimensional array (matrix) S",
    "U": "two-dimensional array (matrix) U",
    "VT": "two-dimensional array (matrix) VT",
    "W": "TODO",
    "XF": "two-dimensional array (matrix) XF",
    "XF_array": "two-dimensional array (matrix) XF_array",
    "b": "vector. see NVIDIA docs",
    "lda": "leading dimension of two-dimensional array used to store matrix A",
    "ldb": "leading dimension of two-dimensional array used to store matrix B",
    "ldc": "leading dimension of two-dimensional array used to store matrix C",
    "ldt": "leading dimension of two-dimensional array used to store matrix Temp",
    "ldu": "leading dimension of two-dimensional array used to store matrix U",
    "ldvt": "leading dimension of two-dimensional array used to store matrix VT",
    "ldxf": "leading dimension of two-dimensional array used to store matrix XF",
    "uplo": "indicates if matrix A lower or upper part is stored, the other part is not referenced.",
    "work": "Working space array.  see NVIDIA docs",
    "Work": "Working space array.  see NVIDIA docs",
    "Workspace": "Working space array.  see NVIDIA docs",
    "lwork": "size of working space array.  see NVIDIA docs",
    "Lwork": "size of working space array.  see NVIDIA docs",
    "rwork": "size of working space array.  see NVIDIA docs",
    "devInfo": "opaque structure.  see NVIDIA docs",
    "devIpiv": "array of size at least min(m,n), containing pivot indices.",
    "ipiv": "array of size at least min(m,n), containing pivot indices.",
    "csrRowPtr": "integer array of m+1 elements that contains the start of every row and the end of the last row plus one",
    "csrColInd": "integer array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) column indices of the nonzero elements of matrix A",
    "csrVal": " array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) nonzero elements of matrix A",
    "descrA": "matrix descriptor of sparse matrix A",
    "csrRowPtrA": "integer array of m+1 elements that contains the start of every row and the end of the last row plus one",
    "csrColIndA": "integer array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) column indices of the nonzero elements of matrix A",
    "csrValA": " array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) nonzero elements of matrix A",
    "csrRowPtrL": "integer array of m+1 elements that contains the start of every row and the end of the last row plus one",
    "csrColIndL": "integer array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) column indices of the nonzero elements of matrix L",
    "csrValL": " array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) nonzero elements of matrix L",
    "csrRowPtrU": "integer array of m+1 elements that contains the start of every row and the end of the last row plus one",
    "csrColIndU": "integer array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) column indices of the nonzero elements of matrix U",
    "csrValU": " array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) nonzero elements of matrix U",
    "h_csrRowPtrA": "integer array of m+1 elements that contains the start of every row and the end of the last row plus one",
    "h_csrColIndA": "integer array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) column indices of the nonzero elements of matrix A",
    "h_csrValA": " array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) nonzero elements of matrix A",
    "h_csrRowPtrL": "integer array of m+1 elements that contains the start of every row and the end of the last row plus one",
    "h_csrColIndL": "integer array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) column indices of the nonzero elements of matrix L",
    "h_csrValL": " array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) nonzero elements of matrix L",
    "h_csrRowPtrU": "integer array of m+1 elements that contains the start of every row and the end of the last row plus one",
    "h_csrColIndU": "integer array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) column indices of the nonzero elements of matrix U",
    "h_csrValU": " array of nnz ( = csrRowPtrA(m) - csrRowPtrA(0) ) nonzero elements of matrix U",
    "cscColPtr": "integer array of n+1 elements that contains the start of every row and the end of the last column plus one",
    "cscRowInd": "integer array of nnz ( = cscColPtrA(m) - cscColPtrA(0) ) row indices of the nonzero elements of matrix A",
    "cscVal": "array of nnz ( = cscColPtrA(m) - cscColPtrA(0) ) nonzero elements of matrix A",
    "trans": "operation that is non- or (conj.) transpose.",
    "tau": "array of dimension at least min(m, n)",
    "TAU": "array of dimension at least min(m, n)",
    "TAUQ": "<type> array of dimension min(m,n). The scalar factors of the elementary reflectors which represent the orthogonal matrix Q",
    "TAUP": "<type> array of dimension min(m,n). The scalar factors of the elementary reflectors which represent the orthogonal matrix P.",
    "side": "indicates if matrix Q is on the left or right of C.",
    "k": "number of elementary reflections.",
    "jobu": "see NVIDIA docs",
    "jobvt": "see NVIDIA docs",
    "jobz": "see NVIDIA docs",
    "tol": "tolerance",
    "issym": "1 if A is symmetric; 0 otherwise",
    "singularity": "-1 if A is invertible. Otherwise, first index j such that U(j,j)â‰ˆ0",
    "x": "vector.  see NVIDIA docs",
    "mu": "vector.  see NVIDIA docs",
    "reorder": "see NVIDIA docs",
    "rankA": "numerical rank of A",
    "min_norm": "||A*x-b||, x=pinv(A)*b",
    "p": "permutation vector. see NVIDIA docs",
    "q": "permutation vector. see NVIDIA docs",
    "P": "permutation vector. see NVIDIA docs",
    "Q": "permutation vector. see NVIDIA docs",
    "h_P": "permutation vector. see NVIDIA docs",
    "h_Q": "permutation vector. see NVIDIA docs",
    "pBuffer": "buffer allocated by the user. see NVIDIA docs",
    "pBufferSizeInBytes": "number of bytes in the buffer",
    "map": "integer array of nnzA indices. see NVIDIA docs",
    "mu0": "initial guess",
    "x0": "initial guess",
    "maxiter": "maximum iterations",
    "left_bottom_corner": "left bottom corner of the box.",
    "right_upper_corner": "right upper corner of the box",
    "num_eigs": "number of eigenvalues",
    "batchSize": "number of systems to be solved",
    "info": "opaque structure.  see NVIDIA docs",
    "internalDataInBytes": "number of bytes of the internal data",
    "workspaceInBytes": "number of bytes of the buffer in numerical factorization",
    "Mp": "the array of offsets corresponding to the start of each row in the arrays Mi and Mx. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.",
    "Mi": "the array of column indices corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "Mx": "the array of values corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "Lp": "the array of offsets corresponding to the start of each row in the arrays Li and Lx. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.",
    "Li": "the array of column indices corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "Lx": "the array of values corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "Up": "the array of offsets corresponding to the start of each row in the arrays Ui and Ux. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.",
    "Ui": "the array of column indices corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "Ux": "the array of values corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "h_Mp": "the array of offsets corresponding to the start of each row in the arrays Mi and Mx. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.",
    "h_Mi": "the array of column indices corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "h_Mx": "the array of values corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "h_Lp": "the array of offsets corresponding to the start of each row in the arrays Li and Lx. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.",
    "h_Li": "the array of column indices corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "h_Lx": "the array of values corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "h_Up": "the array of offsets corresponding to the start of each row in the arrays Ui and Ux. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.",
    "h_Ui": "the array of column indices corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "h_Ux": "the array of values corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.",
    "format": "the enumerated matrix format type",
    "diag": "the enumerated unit diagonal type",
    "zero": "the value below which zero pivot is flagged",
    "boost": "the value which is substituted for zero pivot (if the later is flagged)",
    "report": "the enumerated boosting report type",
    "fastMode": "the enumerated mode type",
    "alg": "the enumerated algorithm type",
    "factAlg": "the enumerated algorithm type",
    "solveAlg": "the enumerated algorithm type",
    "Temp": "the dense matrix that contains temporary workspace",
    "position": "see NVIDIA docs",
    "k1": "see NVIDIA docs",
    "k2": "see NVIDIA docs",
    "incx": "see NVIDIA docs",
    "csrEndPtrA": "see NVIDIA docs",
    "maxite": "see NVIDIA docs",
    "eps": "see NVIDIA docs",
    "itype": "see NVIDIA docs",
    "type": "see NVIDIA docs",
    "value": "see NVIDIA docs",
    "bufferSizeInBytes": "size of buffer in bytes",
    "tolerance": "see NVIDIA docs",
    "max_sweeps": "see NVIDIA docs",
    "sort_eig": "see NVIDIA docs",
    "residual": "see NVIDIA docs",
    "executed_sweeps": "see NVIDIA docs",
    "V": "see NVIDIA docs",
    "params": "see NVIDIA docs",
    "ldv": "see NVIDIA docs",
    "econ": "see NVIDIA docs",
    "sort_svd": "see NVIDIA docs"
}